\chapter{EKF Handling}
\label{chap:EKF_Handling}

In the realm of EKF handling, the primary objective is to estimate the current position coordinates (X, Y, Z). The EKF\_Task, exclusively running on the Tag, initializes an instance of the EKF\_Filter class. During initialization, it reads anchor positions from EEPROM and stores them in the static \blueconsolas{landmarkPositions} matrix.
\vspace{4pt}
\newline
The EKF unfolds in two steps: first, estimating the subsequent state vector, and second, the correction step. To commence estimation, a state vector and covariance matrix are created. The Jacobian matrix of the prediction model and the noise covariance matrix are essential for this step. The Jacobian matrix \blueconsolas{matJacobF} initializes as a 3x3 identity matrix (\ref{eq:matJacobF}), suitable for predicting constant velocity movements. The noise covariance matrix \blueconsolas{matQ} initializes as shown in (\ref{eq:matQ}).

\begin{equation}
	\begin{centering}
		\blueconsolas{matJacobF} =
		\begin{pmatrix}
			1 & 0 & 0 \\
			0 & 1 & 0 \\
			0 & 0 & 1
		\end{pmatrix}
	\end{centering}
	\label{eq:matJacobF}
\end{equation}

\begin{equation}
	\begin{centering}
		\blueconsolas{matQ} =
		\begin{pmatrix}
			0.1 & 0 & 0 \\
			0 & 0.1 & 0 \\
			0 & 0 & 0.1
		\end{pmatrix}
	\end{centering}
	\label{eq:matQ}
\end{equation}

The \yellowconsolas{predictEKF} method is then invoked for predicting the next state. It accepts the Jacobian and noise covariance matrices along with a callback for a custom prediction model (\ref{sub:predictionModel}). The measurement vector \blueconsolas{vecZ} is subsequently created, gathering previously measured distances from the TOF\_Task.

Preparatory to the correction step, the measurement noise covariance matrix \blueconsolas{matR} is established (\ref{eq:matR}). The Jacobian matrix \blueconsolas{matHj} is calculated using the \yellowconsolas{calculateJacobianMatrix} method (\ref{sub:calculateJacobianMatrix}).

\begin{equation}
	\begin{centering}
		\blueconsolas{matR} =
		\begin{pmatrix}
			0.01 & 0 & 0 & 0 & 0 \\
			0 & 0.01 & 0 & 0 & 0 \\
			0 & 0 & 0.01 & 0 & 0 \\
			0 & 0 & 0 & 0.01 & 0 \\
			0 & 0 & 0 & 0 & 0.01 \\
		\end{pmatrix}
	\end{centering}
	\label{eq:matR}
\end{equation}

The Extended Kalman Filter correction step involves the \yellowconsolas{correctEkf} method (\ref{sub:calculateMeasurement}). It takes a callback function for the measurement model, the measurement vector \blueconsolas{vecZ}, noise covariance matrix \blueconsolas{matR}, and the calculated Measurement Jacobian matrix \blueconsolas{matHj}. An Innovation Covariance Matrix and Kalman Gain are calculated, leading to the updated state vector (\blueconsolas{m\_vecX}) and state covariance matrix (\blueconsolas{m\_matP}).

The updated state vector is determined by subtracting the measurement model from the measurement vector, multiplying it by the Kalman Gain, and adding it to the last estimated state vector. The new state covariance matrix is computed by adjusting the previous estimation based on the Kalman Gain.

\section{predictionModel}
\label{sub:predictionModel}
The \yellowconsolas{predictionModel} method is a component of the Extended Kalman Filter (EKF). It predicts the next state of the system based on the current state and a linear motion model. 
As input it takes the current state vector and outputs a new state vector, representing the predicted state of the system. 
\vspace{4pt}
\newline
When called he method calculates the time difference \textit{dt} in seconds between the current state to be estimated and the state that was last estimated. This time difference is crucial for predicting the evolution of the system. 
The time is obtained by using the \yellowconsolas{millis} function. 
\vspace{4pt}
\newline
The new position of the system is estimated linearly. The method takes the three-dimensional directional vector from the position before the last estimated vector to the last estimated vector. It multiplies this directional vector by the elapsed time \textit{dt} to obtain the prediction for the new state vector. 
This assumes a simple linear motion model where the system's position changes linearly with time.
\vspace{4pt}
\newline
Lastly he method updates internal variables, such as the last recorded time and transition vector, to ensure accurate time tracking.

\section{calculateJacobianMatrix}
\label{sub:calculateJacobianMatrix}
The  \yellowconsolas{calculateJacobianMatrix} method, as its name implies, is responsible for computing the Jacobian matrix (\blueconsolas{matHj}) used in the correction step of the Extended Kalman Filter (EKF). When operating in three dimensions with the utilization of five anchors, the dimension of \blueconsolas{matHj} is 5x3.
\vspace{4pt}
\newline
Upon initialization, all values of \blueconsolas{matHj} are set to zero. Subsequently, for each landmark, the offset of the tag's position in each coordinate direction (\blueconsolas{dx}, \blueconsolas{dy}, and \blueconsolas{dz}) is calculated using the latest state vector. These offsets are then utilized to compute the Euclidean distance to each landmark, denoted as \blueconsolas{range} and computed as $\textrm{range}_n = \sqrt{(dx_n)^2 + (dy_n)^2 + (dz_n)^2}$.
\vspace{4pt}
\newline
The resulting \blueconsolas{matHj} matrix is populated following the structure shown in equation \ref{eq:matHj}:

\begin{equation}
	\begin{centering}
		\blueconsolas{matHj} =
		\begin{pmatrix}
			\frac{-\textrm{dx}_1}{\textrm{range}_1} & \frac{-\textrm{dy}_1}{\textrm{range}_1} & \frac{-\textrm{dz}_1}{\textrm{range}_1} \\
			\frac{-\textrm{dx}_2}{\textrm{range}_2} & \frac{-\textrm{dy}_2}{\textrm{range}_2} & \frac{-\textrm{dz}_2}{\textrm{range}_2} \\
			\vdots & \vdots & \vdots \\
			\frac{-\textrm{dx}_n}{\textrm{range}_n} & \frac{-\textrm{dy}_n}{\textrm{range}_n} & \frac{-\textrm{dz}_n}{\textrm{range}_n} \\
		\end{pmatrix}
	\end{centering}
	\label{eq:matHj}
\end{equation}

\section{calculateMeasurement}
\label{sub:calculateMeasurement}
The \yellowconsolas{calculateMeasurement} function, akin to \yellowconsolas{calculateJacobianMatrix}, also contributes to the correction step within the Extended Kalman Filter. 
Its role involves taking the current state vector, which includes the last outputted state vector coordinates, and determining the offset in the X-, Y-, and Z-directions. Subsequently, it calculates the Euclidean distance to every landmark.
\vspace{4pt}
\newline
Initiating the process, the function sets up variables and matrices for storing calculated values. For each landmark, it computes the offset of the tag's position in each coordinate direction (\blueconsolas{dx}, \blueconsolas{dy}, and \blueconsolas{dz}) using the current state vector. The Euclidean distance (\blueconsolas{range}) to each landmark is then computed based on these offsets:
$\textrm{range}_n = \sqrt{(dx_n)^2 + (dy_n)^2 + (dz_n)^2}$.
Moving forward, the calculated Euclidean distances undergo a transformation. They are divided by the corresponding measured distances to each specific landmark, and the result is multiplied by (-1). The final output is organized into a 1x5 column vector and returned like shown in equation \ref{eq:calculateMeasurement}. 

\begin{equation}
	\begin{centering}
		\blueconsolas{measurement} =
		\begin{pmatrix}
			\textrm{range}_1 \\
			\textrm{range}_2 \\
			\vdots \\
			\textrm{range}_n 
		\end{pmatrix}
	\end{centering}
	\label{eq:calculateMeasurement}
\end{equation}
