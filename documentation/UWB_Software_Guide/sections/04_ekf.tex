\chapter{EKF Handling}
\label{chap:EKF_Handling}
\section{Estimation Process}
\label{sec:Estimation_Process}
In the realm of EKF handling, the primary objective is to estimate the current position coordinates (X, Y, Z). The EKF\_Task, exclusively running on the Tag, initializes an instance of the EKF\_Filter class. During initialization, it reads anchor positions from EEPROM and stores them in the static \blueconsolas{landmarkPositions} matrix.
\vspace{4pt}
\newline
The EKF unfolds in two steps: first, estimating the subsequent state vector, and second, the correction step. To commence estimation, a state vector and covariance matrix are created. The Jacobian matrix of the prediction model and the noise covariance matrix are essential for this step. The Jacobian matrix \blueconsolas{matJacobF} initializes as a 3x3 identity matrix (\ref{eq:matJacobF}), suitable for predicting constant velocity movements. The noise covariance matrix \blueconsolas{matQ} initializes as shown in (\ref{eq:matQ}).
\begin{equation}
	\begin{centering}
		\blueconsolas{matJacobF} =
		\begin{pmatrix}
			1 & 0 & 0 \\
			0 & 1 & 0 \\
			0 & 0 & 1
		\end{pmatrix}
	\end{centering}
	\label{eq:matJacobF}
\end{equation}
\begin{equation}
	\begin{centering}
		\blueconsolas{matQ} =
		\begin{pmatrix}
			0.1 & 0 & 0 \\
			0 & 0.1 & 0 \\
			0 & 0 & 0.1
		\end{pmatrix}
	\end{centering}
	\label{eq:matQ}
\end{equation}

The \yellowconsolas{predictEKF} method is then invoked for predicting the next state. It accepts the Jacobian and noise covariance matrices along with a callback for a custom prediction model (\ref{sub:predictionModel}). The measurement vector \blueconsolas{vecZ} is subsequently created, gathering previously measured distances from the TOF\_Task.

Preparatory to the correction step, the measurement noise covariance matrix \blueconsolas{matR} is established (\ref{eq:matR}). The Jacobian matrix \blueconsolas{matHj} is calculated using the \yellowconsolas{calculateJacobianMatrix} method (\ref{sub:calculateJacobianMatrix}).

\begin{equation}
	\begin{centering}
		\blueconsolas{matR} =
		\begin{pmatrix}
			0.01 & 0 & 0 & 0 & 0 \\
			0 & 0.01 & 0 & 0 & 0 \\
			0 & 0 & 0.01 & 0 & 0 \\
			0 & 0 & 0 & 0.01 & 0 \\
			0 & 0 & 0 & 0 & 0.01 \\
		\end{pmatrix}
	\end{centering}
	\label{eq:matR}
\end{equation}

The Extended Kalman Filter correction step uses the \yellowconsolas{correctEkf} method (\ref{sub:correctEkf}) to refine the previously taken estimation. 

\section{EKF\_Filter Class}
\label{sec:EKF_Filter Class}

\subsection{EKF\_Filter Variables}
\label{sub:EKF_Filter_Variables}

\subsubsection{Private Variables}

\begin{itemize}
	
	\item \textbf{Matrix<double, DIM\_X, 1> m\_vecX}
	The m\_vecX variable is a 1x3 column vector that holds the X-, Y- and Z-Coordinates of the Tag that the EKF estimated in the most recent calculation.
	It is initialized as a zero vector. 
	
	\item \textbf{Matrix<double, DIM\_X, DIM\_X> m\_matP}
	\newline
	The m\_matP variable is a 3x3 matrix and represents the state covariance matrix of the last estimation. 
	\item \textbf{static uint32\_t lastTime}
	\newline
	The lastTime a static variable is representing the timestamp in milliseconds of the last update. 
	It is used to calculate the time difference between consecutive predictions in the Extended Kalman Filter. 
	\item \textbf{static Matrix<double, DIM\_X, 1> x\_kminus1}
	\newline
	x\_kminus1 is a static variable representing the predicted state vector from the previous time step in the Extended Kalman Filter. 
	It is a key element in the EKF's prediction step, storing the predicted state to be used as the initial estimate for the subsequent prediction. 
	The variable is updated during each prediction to reflect the evolving state of the system.
	\item \textbf{static Matrix<double, NUM\_LANDMARKS, 3> landmarkPositions}
	\newline
	landmarkPositions is a static matrix representing the positions of landmarks in a three-dimensional space. 
	It is of type Matrix<double, NUM\_LANDMARKS, 3> and is used within the Extended Kalman Filter implementation to calculate the Jacobian matrix and measurement vector for the measurement model. 
	The matrix is initialized to a zero matrix and later filled with landmark positions read from EEPROM in the read\_landmarks\_from\_eeprom function described in \ref{sub:read_landmarks_from_eeprom}.
\end{itemize}

\subsection{Matrix<double, DIM\_X, 1>\& vecX()}
\label{sub:vecX}
vecX() is a getter function that returns the current m\_vecX matrix. 

\subsection{Matrix<double, DIM\_X, DIM\_X>\& matP()}
\label{sub:matP}
matP() is a getter function that returns the current m\_matP matrix. 

\subsection{predict}
\label{sub:predict}
The predict method performs the prediction step of the filter. 
It takes as input the state transition matrix (matF) and the process noise covariance matrix (matQ). 
The prediction step for the state vector (m\_vecX) is cone by multiplying it with the state transition matrix. 
The presiction of the state covariance matrix (m\_matP) is done by multiplying it with the state transition matrix and the transpose of the multiplying it with the state transition matrix then adding the process noise covariance matrix. 


The method updates the estimated state vector (m\_vecX) and the state covariance matrix (m\_matP) based on the provided matrices, representing the prediction of the system's state in the absence of new measurements.

\subsection{correct}
\label{sub:correct}
In the correct method . 
Parameters are the measurement vector (vecZ) represents the actual sensor measurements, the measurement noise covariance matrix (matR) that characterizes the uncertainty in these measurements, and the measurement Jacobian matrix (matH) relates the state vector to the measurement space. 
\vspace{4pt}
\newline
The method computes the innovation covariance (matSk), Kalman Gain (matKk), and updates the state vector and covariance matrix based on the difference between the predicted and actual measurements. This correction step refines the state estimate by assimilating new information from sensor measurements while accounting for measurement uncertainties.

\subsection{predictEkf}
\label{sub:predictEkf}
The predictEkf method is almost identical to the predict method. 
It differs from it in this respect that it does not take the actual measurement vector vecZ but rather uses the predictionModel methodn to predict an vecZ from the state vector m\_vecX. 

\subsection{correctEkf}
\label{sub:correctEkf}
The correctEkf method is almost identical to the correct method. 
It differs from it in this respect that it does not take the actual measurement vector vecZ but rather uses the predictionModel method to predict an vecZ from the state vector m\_vecX. 

\subsection{read\_landmarks\_from\_eeprom}
\label{sub:read_landmarks_from_eeprom}
The read\_landmarks\_from\_eeprom method reads landmark positions from EEPROM and populates the landmarkPositions matrix. It iterates over the landmarks, calculates the EEPROM addresses, and retrieves the stored x, y, and z coordinates. 
The method is part of the EKF initialization process, ensuring the filter has access to landmark positions stored in non-volatile memory.

\subsection{predictionModel}
\label{sub:predictionModel}
The \yellowconsolas{predictionModel} method is a component of the Extended Kalman Filter (EKF). It predicts the next state of the system based on the current state and a linear motion model. 
As input it takes the current state vector and outputs a new state vector, representing the predicted state of the system. 
\vspace{4pt}
\newline
When called he method calculates the time difference \textit{dt} in seconds between the current state to be estimated and the state that was last estimated. This time difference is crucial for predicting the evolution of the system. 
The time is obtained by using the \yellowconsolas{millis} function. 
\vspace{4pt}
\newline
The new position of the system is estimated linearly. The method takes the three-dimensional directional vector from the position before the last estimated vector to the last estimated vector. It multiplies this directional vector by the elapsed time \textit{dt} to obtain the prediction for the new state vector. 
This assumes a simple linear motion model where the system's position changes linearly with time.
\vspace{4pt}
\newline
Lastly he method updates internal variables, such as the last recorded time and transition vector, to ensure accurate time tracking.

\subsection{calculateJacobianMatrix}
\label{sub:calculateJacobianMatrix}
The  \yellowconsolas{calculateJacobianMatrix} method, as its name implies, is responsible for computing the Jacobian matrix (\blueconsolas{matHj}) used in the correction step of the Extended Kalman Filter (EKF). When operating in three dimensions with the utilization of five anchors, the dimension of \blueconsolas{matHj} is 5x3.
\vspace{4pt}
\newline
Upon initialization, all values of \blueconsolas{matHj} are set to zero. Subsequently, for each landmark, the offset of the tag's position in each coordinate direction (\blueconsolas{dx}, \blueconsolas{dy}, and \blueconsolas{dz}) is calculated using the latest state vector. These offsets are then utilized to compute the Euclidean distance to each landmark, denoted as \blueconsolas{range} and computed as $\textrm{range}_n = \sqrt{(dx_n)^2 + (dy_n)^2 + (dz_n)^2}$.
\vspace{4pt}
\newline
The resulting \blueconsolas{matHj} matrix is populated following the structure shown in equation \ref{eq:matHj}:

\begin{equation}
\begin{centering}
	\blueconsolas{matHj} =
	\begin{pmatrix}
		\frac{-\textrm{dx}_1}{\textrm{range}_1} & \frac{-\textrm{dy}_1}{\textrm{range}_1} & \frac{-\textrm{dz}_1}{\textrm{range}_1} \\
		\frac{-\textrm{dx}_2}{\textrm{range}_2} & \frac{-\textrm{dy}_2}{\textrm{range}_2} & \frac{-\textrm{dz}_2}{\textrm{range}_2} \\
		\vdots & \vdots & \vdots \\
		\frac{-\textrm{dx}_n}{\textrm{range}_n} & \frac{-\textrm{dy}_n}{\textrm{range}_n} & \frac{-\textrm{dz}_n}{\textrm{range}_n} \\
	\end{pmatrix}
\end{centering}
\label{eq:matHj}
\end{equation}

\subsection{calculateMeasurement}
\label{sub:calculateMeasurement}
The \yellowconsolas{calculateMeasurement} function, akin to \yellowconsolas{calculateJacobianMatrix}, also contributes to the correction step within the Extended Kalman Filter. 
Its role involves taking the current state vector, which includes the last outputted state vector coordinates, and determining the offset in the X-, Y-, and Z-directions. Subsequently, it calculates the Euclidean distance to every landmark.
\vspace{4pt}
\newline
Initiating the process, the function sets up variables and matrices for storing calculated values. For each landmark, it computes the offset of the tag's position in each coordinate direction (\blueconsolas{dx}, \blueconsolas{dy}, and \blueconsolas{dz}) using the current state vector. The Euclidean distance (\blueconsolas{range}) to each landmark is then computed based on these offsets:
$\textrm{range}_n = \sqrt{(dx_n)^2 + (dy_n)^2 + (dz_n)^2}$.
Moving forward, the calculated Euclidean distances undergo a transformation. They are divided by the corresponding measured distances to each specific landmark, and the result is multiplied by (-1). The final output is organized into a 1x5 column vector and returned like shown in equation \ref{eq:calculateMeasurement}. 

\begin{equation}
\begin{centering}
	\blueconsolas{measurement} =
	\begin{pmatrix}
		\textrm{range}_1 \\
		\textrm{range}_2 \\
		\vdots \\
		\textrm{range}_n 
	\end{pmatrix}
\end{centering}
\label{eq:calculateMeasurement}
\end{equation}
