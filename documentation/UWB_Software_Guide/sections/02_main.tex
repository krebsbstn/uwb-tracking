\chapter{Main File Structure}
This chapter outlines the structure and organization of the main.cpp file of the UWB Project that runs on all of the UWB devices.

\section{Identification Parameters}
All UWB devices, irrespective of their function as anchors or tags, utilize the same codebase during the flashing process. 
The differentiation between these devices relies on two critical parameters configured during the initial flashing procedure. 
These parameters serve a dual purpose: defining the device's role as a tag or anchor and assigning a unique device identifier.
\vspace{4pt}
\newline
In essence, these parameters not only dictate whether a device acts as a tag or an anchor but also bestow each device with a distinctive identifier, enabling them to autonomously determine their respective addresses. 
This configuration approach ensures versatility and individuality among the UWB devices while maintaining a unified codebase.

\subsection{Set Identification Parameters}
The configuration of each device is primarily defined by two key parameters: the device ID and its designated role. 
To establish these parameters, a setup process is executed through the preproduction\_eeprom\_settings function, which is integrated into the setup section of the main.cpp file. 
This function accepts the current role and device ID as uint8\_t variables and records them in the EEPROM memory at an arbitrary position.
\vspace{4pt}
\newline
It is important to note that this setup process should only be performed once per device, typically during the initial configuration. 
Once the parameters are set and saved in the EEPROM, there is no need to invoke the preproduction\_eeprom\_settings function again during subsequent flashing processes unless a change in device configuration is desired. 
This approach streamlines the device setup procedure and ensures the persistence of the specified parameters across device power cycles.

\subsubsection{Role}
The role parameter is pivotal in determining whether a device functions as a tag or an anchor within the system. 
This parameter is stored in the EEPROM memory at address 0 and is represented by a binary value of 0 or 1. 
Throughout the codebase, this parameter is accessed and utilized through the IS\_INITIATOR constant.
\vspace{4pt}
\newline
If the value stored at EEPROM address 0 is 1, the device is configured to act as a tag. 
In this mode, it typically takes on the role of initiating UWB messages and serves specific functions accordingly. Conversely, if the value is 0, the device operates as an anchor. 
In this capacity, it primarily responds to incoming UWB messages, contributing to the overall UWB system by providing reference points and data to other devices.
\vspace{4pt}
\newline
This parameterization approach allows for dynamic role assignment and behavior based on a single value, making the system flexible and adaptive to the needs of each device.

\subsubsection{Device ID}
The device ID is also stored in the EEPROM, and it serves the crucial function of assigning a unique address to each device. 
This individualized addressing is essential for facilitating clear and unambiguous communication through UWB packages within the system. 
Each device must possess a distinct device ID to ensure that messages are accurately addressed to the intended recipient, and that devices can be uniquely identified in the network.
\vspace{4pt}
\newline
By storing the device ID in EEPROM, the ID can persist across power cycles and reboots, maintaining consistent identification for each device in the system. 
This approach is vital for seamless and reliable communication and data exchange between UWB devices, ensuring that messages reach their intended destinations without ambiguity.

\subsection{Address}
To ensure the secure and accurate encryption of UWB packages using the Advanced Encryption Standard (AES), each device requires a unique 32-bit address. 
This address is essential for enabling precise encryption and decryption processes. 
By encrypting a message with the destination address, the system guarantees that only the designated receiver can successfully decrypt the message. 
As a result, every device, both anchors and tags, must be aware of their own unique address.
\vspace{4pt}
\newline
For anchors, their individual addresses are directly determined by their respective device IDs. 
Each anchor selects its address from a predefined list based on its specific device ID. 
In contrast, the address for tags remains constant and is universally known across all devices as the global constant INITIATOR\_ADDR. 
This address assignment methodology ensures that each device can securely encrypt and decrypt messages using the appropriate addresses, contributing to the overall data security and integrity of the UWB communication system.

\section{User Input}
User input to change the current operating mode is facilitated through User Button 1. 
By associating an interrupt with this button, the ble\_kill\_flag is set, and the current\_mode variable is updated accordingly. 
For a comprehensive understanding of how these components are managed, please refer to section \ref{sec:Ble_Task}. 
This section will delve into the specifics of how the interrupt, ble\_kill\_flag, and current\_mode variable interact to facilitate seamless mode switching in the tag device's operation. 

\section{Main Variables}
\begin{itemize}
	\item \textbf{double distances[NUM\_LANDMARKS]}
	\newline
	This array stores the measured distances to landmarks, providing input for the Extended Kalman Filter (EKF) used for position estimation.
	It is constantly updated by an instance of the TofInitiator class. 
	
	\item \textbf{uint8\_t ble\_kill\_flag}
	\newline
	A flag used to control the operation of the BLE-Task, allowing for a smooth transition between operational and config mode.
	
	\item \textbf{coordinate own\_position}
	\newline
	A coordinate structure that holds the estimated 3D position of the UWB device, which is continuously updated by the EKF-Task. 
	
	\item \textbf{DynamicJsonDocument latest\_rx\_diagnostics}
	\newline
	This JSON document stores the most recent diagnostics information received from other UWB devices. It is utilized in UWB anchor mode to share information to an MQTT broker.
	
	\item \textbf{uint8\_t current\_mode}
	\newline
	Represents the operating mode of the UWB device, distinguishing between config and operational mode. It is toggled based on user input and controls the execution of relevant tasks.
	
	\item \textbf{uwb\_addr dest\_addr\_list[]}
	\newline
	An array containing UWB addresses of responder devices. 
	In UWB initiator mode, this list is used for initiating TOF measurements with multiple responder devices.
	
	\item \textbf{Task handles (ekf\_task\_handle, tdoa\_task\_handle, tof\_task\_handle, ble\_task\_handle, mqtt\_task\_handle)}
	\newline
	These handles are used to manage and control the execution of different FreeRTOS tasks responsible for specific functionalities in the UWB device.
\end{itemize}

\section{Main Functions}
\label{sec:Main_Functions}

\subsection{setup}
\label{subsec:setup}
The setup function in the UWB device code serves as the initialization routine that is run first when the ESP32 is powered on. 
It begins by configuring serial communication for debugging and EEPROM for persistent data storage. 
The pin where the user button 1 is connected to is set as an input and the user\_1\_button function is attached to it as an interrupt routine. 
Furthermore the three pins for the user LEDs are defined as output and all set to zero upon initialization. 
The current mode is set to "uwb\_mode" and the MQTT- as well as the TOF-Task are started. 
\vspace{4pt}
\newline
The function then checks if the device, it is running on, is defined as an initiator. 
If so the BLE- and EKF-Task are started as well. 
\vspace{4pt}
\newline
If the device is defined as a responder, it reads the JSON file named 
\newline
"uwb\_diacnostic\_type.json" from the SPIFFS on the ESP32.
It then creates a DynamicJsonDocument object (latest\_rx\_diagnostics) with three times the size of the JSON file, providing extra space for storing communication channel data.
The code proceeds to deserialize the contents of the JSON file into the latest\_rx\_diagnostics object. If there's an error during deserialization, it prints an error message to the serial monitor; otherwise, it indicates successful insertion of the JSON template. The file is then closed. Finally, the device ID is retrieved from EEPROM, and the "DeviceId" field in the latest\_rx\_diagnostics JSON document is set to this device ID so the MQTT broker can tell where from what responder the data originated. 

\subsection{void user\_1\_button}
\label{subsec:user_1_button}
The user\_1\_button function serves as an interrupt routine arrached to the user button 1. 
First the interrupt is detached. 
If the device is an initiator and in uwb\_mode it will toggle the ble\_kill\_flag and set to current mode to ble\_mode. 
If it is in ble\_mode it will toggle the ble\_kill\_flag and set to current mode to uwb\_mode. 
Lastly the interrupt gets attached back to the user button 1. 

\subsection{void animate\_leds}
\label{subsec:animate_leds}
This function sequentially illuminates and extinguishes LEDs in a predefined pattern, creating a visual animation. 
It provides a quick and noticeable indication of a specific mode. 
The LEDs involved in the animation are connected to GPIO pins on the ESP32. 

\subsection{void preproduction\_eeprom\_settings}
\label{subsec:preproduction_eeprom_settings}
This function takes two parameters - dev\_id representing the unique device identifier and is\_initiator indicating whether the device operates as an initiator or not. 
It writes these values into EEPROM, ensuring that the correct device ID and role information are stored persistently. This initialization process is crucial for the proper functioning of other tasks and functionalities in the UWB device, as they depend on the settings retrieved from EEPROM.

\subsection{Freertos Tasks}
\label{subsec:Freertos_Tasks}
The functions for the TOF-, MQTT-, BLE-, and EKF-Task are handeled by FreeRTOS to ensure concurrent and parallel execution of those functionalities within the device since they are the most critical to the operation. 
There functions are handled separately in the sections \ref{chap:tof_task} - \ref{sub:MQTT_Task}. 

\section{Scheduler}
\label{sec:Scheduler}
To efficiently measure distances to multiple anchors simultaneously, calculate their respective positions, and transmit the data to the software running on the devices, a scheduling system is implemented. 
This scheduling system is powered by the FreeRTOS library, an open-source real-time operating system, which leverages the dual-kernel capabilities of the ESP32 microcontroller.
\vspace{4pt}
\newline
The dual-kernel architecture ensures that critical tasks, like estimating distances, remain uninterrupted, reducing the risk of producing corrupted data. 
All tasks are initialized, started, and halted within the 'main.cpp' file, creating a well-structured and organized framework for managing these essential operations.

\subsection{TOF\_Task}
\label{chap:tof_task}

In the context of TOF-Task, it plays a pivotal role in the overall system, particularly in the domain of Time-of-Flight (TOF) distance measurement and positioning. This section outlines the primary functions of TOF-Task in a narrative form.
\vspace{4pt}
\newline
The initial task for TOF-Task is to identify the device's role within the system, specifically whether it should operate as a TofInitiator or a TofResponder. This role assignment is crucial as it dictates the device's behavior and responsibilities throughout the entire process.
\vspace{4pt}
\newline
Once the device's role is established, TOF-Task proceeds to create an instance of the appropriate object, either TofInitiator or TofResponder, and initializes it. This instantiated object assumes the critical responsibility of managing the distance measurement process.
\vspace{4pt}
\newline
At the core of TOF-Task's operation lies the facilitation of distance measurements. If the device takes on the role of a responder, it remains in a passive stance during the measurement process, awaiting initiation from another device. Conversely, when the device serves as an initiator, it leads the way in conducting distance measurements.
\vspace{4pt}
\newline
In scenarios where the device functions as the initiator, a crucial user feedback mechanism comes into play. User LED 1 is activated to provide visual feedback, signaling that this particular device is taking the initiative in distance measurement and position estimation. Such feedback proves invaluable, especially in systems involving multiple devices, ensuring users are aware of which device is actively involved in determining the position.
\vspace{4pt}
\newline
For the initiator role, TOF-Task manages the storage of calculated distances. These distances, representing measurements to each anchor, are stored within the "double distances[]" array. This array serves as a vital source of information for the subsequent stages of the positioning algorithm.
\vspace{4pt}
\newline
In summary, TOF-Task serves as the central orchestrator, dynamically allocating roles to devices as initiators or responders and configuring the corresponding objects to execute distance measurements. This dynamic allocation of tasks ensures the effective functioning of the system, and when necessary, it offers user feedback to enhance the transparency of the positioning process.

\subsection{EKF-Task}
The EKF task is a critical component of the system, running exclusively on the tag device. 
Its primary purpose is to leverage the information provided by the "double distances[]" array, which contains the distances to all available anchors. 
With this data, the EKF task performs calculations to estimate the tag's position. 
This estimation process is triggered every time when all landmark distances are covered, ensuring that the system continually updates its understanding of the tag's location.
\vspace{4pt}
\newline
The EKF algorithm, a cornerstone of this task, incorporates statistical techniques and dynamic models to refine the accuracy of the position estimate. 
By doing so, it can effectively handle factors like noise and uncertainties, making it a robust solution for real-time positioning.
\vspace{4pt}
\newline
Once the EKF-task completes its calculations, the resulting X and Y coordinate values are transmitted through the UART interface and via MQTT.  
\vspace{4pt}
\newline
For a comprehensive understanding of the theory and principles that underpin the Extended Kalman Filter and its role in this system, you'll find in-depth coverage in Chapter \ref{chap:EKF_Handling}. 
This chapter will delve into the mathematical and conceptual foundations of the EKF, ensuring that readers gain a clear grasp of how it operates and contributes to the overall functionality of the system.

\subsection{BLE\_Task}
\label{sec:Ble_Task}
Similar to the EKF-Task, the BLE-Task is designed to run exclusively on the tag device, and it serves two primary objectives.
\vspace{4pt}
\newline
The first objective is to facilitate device configuration, a process carried out through Bluetooth connectivity with the dedicated ``UWB Configuration`` desktop software. This configuration process entails defining the coordinates of each anchor device and saving these values in the device's EEPROM. A comprehensive guide on how to connect the tag device with the desktop software can be found in the UWB User Guide.
\vspace{4pt}
\newline
The second objective of the BLE-Task is to relay the current position of the tag device via Bluetooth to the corresponding desktop software. The software then plots these positions in an X-Y coordinate system, providing a real-time visual representation of the tag's movements.
\vspace{4pt}
\newline
When the BLE-Task is first initialized, it instantiates the BleConfigLoader class. The workings of this class, along with the broader Bluetooth management process, will be expounded upon in the forthcoming chapter, referenced as \ref{chap:Bluetooth_Handling}.
\vspace{4pt}
\newline
The tag device operates in two distinct modes saved in the current\_mode variable. The first is the uwb\_mode, which serves as its standard operating mode. In this mode, the device performs distance measurements, calculates its own position, and transmits this information via UART, as previously described in \ref{chap:tof_task}.
\vspace{4pt}
\newline
The other operational mode is the ble\_mode, which is exclusively focused on maintaining a connection with the desktop software. 
In this mode the device waits for the trigger from the UWB Configuration software to take in the newly inputted anchor positions and save them into the EEPROM. 
It also outputs the currently saved anchor positions so that they can be displayed and changed in the UWB Configuration desktop software. 

\subsubsection{Output current position}
In the default startup scenario, where the uwb\_mode is automatically selected without any additional user input, the BLE-Task is responsible for taking the currently estimated position from the global own\_position variable and transmitting it via Bluetooth. 
This transmission is achieved using the send\_position method of the BleConfigLoader class. Detailed insight into the functionality of this process will be provided in the forthcoming chapter, referenced as \ref{chap:Bluetooth_Handling}.
\vspace{4pt}
\newline
This continuous updating procedure persists indefinitely, with the current position being sent repeatedly, unless the ble\_kill\_flag is triggered. 
The flag is set when a user initiates a mode change to ble\_mode by pressing user button 1.
\vspace{4pt}
\newline
This mode-switching functionality ensures that the device can seamlessly transition between its primary operating modes based on user input. 

\subsection{MQTT\_Task}
\label{sub:MQTT_Task}
The MQTT\_Task function handles all the MQTT communication. 
It first determines if it is run by the tag or any responder and figuring out its device ID by reading the EEPROM. 
Then it creates a string identifier (String clientId) containing its device ID so the MQTT messages can be told apart from where they originated from. 
\vspace{4pt}
\newline
Subsequently, the function creates an instance of the MqttClient class, encapsulating the essential functionality for MQTT communication. 
This includes setting up the MQTT topic ("uwb\_devices"), specifying the MQTT server details, providing WiFi credentials, and configuring a buffer size for efficient data handling.
\vspace{4pt}
\newline
Within the core of the function lies an infinite loop that serves as the heartbeat of the MQTT communication task. 
The primary objective of this loop is to ensure the persistent operation of the MQTT client. 
Consequently, the mqttClient.update() method is called at every iteration, allowing the client to handle incoming messages and maintain the MQTT connection.
\vspace{4pt}
\newline
As part of the communication strategy, the MQTT\_Task function publishes messages to specific MQTT topics based on the device's role. 
In cases where the device is an initiator (is\_initiator = 1), it publishes position information, formatted as a JSON string, to the "tag/{dev\_id}/position" topic. 
Conversely, if the device is not an initiator (is\_initiator = 0), it publishes UWB diagnostics information, serialized into JSON, to the "anchor/{dev\_id}/uwb\_info" topic.
\vspace{4pt}
\newline
This task structure enables the integration of the device into a larger Ultra-Wideband (UWB) communication system. 
It showcases the capability to disseminate critical information, such as device positions or UWB diagnostics, via the MQTT protocol. 
The inclusion of delays between message publications controls the communication frequency, aligning with the specific requirements of the UWB communication system. 

\subsubsection{Configuration}
When the user triggers a mode change to ble\_mode by pressing button 1, the ble\_kill\_flag is activated, which effectively terminates the loop responsible for continuously transmitting the current position.
\vspace{4pt}
\newline
In the ble\_mode, the device first retrieves its current configuration, encompassing all previously saved anchor positions, from the EEPROM. This retrieval process is achieved through the load\_config\_from\_eeprom method of the BleConfigLoader class. 
Subsequently, the device compiles this configuration data into a string formatted as a JSON object and transmits it via Bluetooth, using the save\_config\_to\_ble method. 
This JSON-formatted data includes the anchor positions.
\vspace{4pt}
\newline
Following this configuration update transmission, a new loop commences. In this loop, the device continually receives the most up-to-date anchor positions sent from the configurator device via Bluetooth. 
These positions are then saved locally on the tag device, and the new anchor configuration is conveyed back to the configurator device, ensuring that the positions are received and updated accurately.
\vspace{4pt}
\newline
In addition to this configuration exchange, the animate\_leds function is invoked, causing the user LEDs to flash in a distinct pattern. 
This visual feedback serves as an indicator to the user that the device is in Bluetooth configuration mode.
\vspace{4pt}
\newline
The configuration loop persists until the "Save Config" button is pressed within the UWB Configuration desktop GUI. 
This action initiates the sending of a character to the tag device, triggering the save\_config\_to\_eeprom method. 
This method is responsible for writing the updated anchor coordinates into the EEPROM of the device and subsequently restarting the device with the new configuration in place. 
This completes the process of updating and saving anchor positions for the tag device during its operation in ble\_mode.



